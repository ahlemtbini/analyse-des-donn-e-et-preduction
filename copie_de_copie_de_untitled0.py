# -*- coding: utf-8 -*-
"""Copie de Copie de Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PK5RNcBQnXkYszOSM8FtrOHZTPvRMWUQ

# **partie analyse des donnÃ©es**
"""

import pandas as pd 
data=pd.read_csv("/content/drive/MyDrive/GlobalLandTemperaturesByCity.csv")
print("Data Info")
data.info()

data.head()

data.shape

data.dtypes

data.describe()

data['Country'].value_counts()

data[["Country","AverageTemperature"]].groupby(["Country"],as_index = False).mean().sort_values(by = "AverageTemperature",ascending = False).style.background_gradient("Greens")

data[["Latitude","AverageTemperature"]].groupby(["Latitude"],as_index = False).mean().sort_values(by = "AverageTemperature",ascending = False).style.background_gradient("Greens")

data[["Longitude","AverageTemperature"]].groupby(["Longitude"],as_index = False).mean().sort_values(by = "AverageTemperature",ascending = False).style.background_gradient("Greens")

import numpy as np
import seaborn as sns 
import matplotlib.pyplot as plt 
sns.set(style='whitegrid')
f, ax = plt.subplots(1,1, figsize=(12, 8))
ax = sns.distplot(data['AverageTemperature'], kde = True, color = 'c')
plt.title('Distribution of AverageTemperature')

#preparing data for modeling
#Converting category labels into numerical using LabelEncoder
from sklearn.preprocessing import LabelEncoder
label = LabelEncoder()
label.fit(data.dt.drop_duplicates())
data.dt = label.transform(data.dt)
label.fit(data.Country.drop_duplicates())
data.Country = label.transform(data.Country)
label.fit(data.City.drop_duplicates())
data.City = label.transform(data.City)
label.fit(data.Latitude.drop_duplicates())
data.Latitude= label.transform(data.Latitude)
label.fit(data.Longitude.drop_duplicates())
data.Longitude= label.transform(data.Longitude)
data.dtypes

#  correlation or dependence between features
f, ax = plt.subplots(1, 1, figsize=(10, 10))
ax = sns.heatmap(data.corr(), annot=True, cmap='cool')

"""

```
# Ce texte est au format code
```

# **regression lineaire**"""

#split data
data.dropna(inplace=True)
data.head()

Y = data.AverageTemperature
X = data.drop(["AverageTemperature","AverageTemperatureUncertainty","City","Latitude","Longitude"], axis = 1)
X.head()

Y.head()

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.33, random_state = 42)

print("X_train shape {}, len {}.".format(X_train.shape,len(X_train)))
print("X_test shape {}, len {}.".format(X_test.shape,len(X_test)))
print("Y_train shape {}, len {}.".format(y_train.shape,len(y_train)))
print("Y_test shape {}, len {}.".format(y_test.shape,len(y_test)))

#We have defined the list in which we will save the model results for later comparison.
results = []

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train) 
X_test = scaler.transform(X_test)

from sklearn.linear_model import LinearRegression
from sklearn import metrics
from sklearn.metrics import r2_score
lr = LinearRegression()
lr.fit(X_train, y_train)
predict = lr.predict(X_test)
score = r2_score(y_test,predict)
results.append(score)

print("r_square score --> ",score)
print('Mean Absolute Error -->', metrics.mean_absolute_error(y_test, predict))
print('Mean Squared Error -->', metrics.mean_squared_error(y_test, predict))
print('Root Mean Squared Error -->', np.sqrt(metrics.mean_squared_error(y_test, predict)))

df_linearRegression = pd.DataFrame({'Actual': y_test, 'Predicted': predict})
df_linearRegression.head()

from yellowbrick.regressor import PredictionError
visualizer = PredictionError(lr)
visualizer.fit(X_train, y_train)  
visualizer.score(X_test, y_test)        
visualizer.show();

"""# **modele de prophet**"""

import pandas as pd 
def parser(x):
    return pd.datetime.strptime(x, '%Y-%m-%d')
 
temperatures = pd.read_csv('/content/drive/MyDrive/GlobalLandTemperaturesByCity.csv', header=0, parse_dates=[0], index_col=0, squeeze=True, date_parser=parser)

from fbprophet import Prophet

temperatures.dropna(inplace=True)
resample = temperatures.resample('AS')
yearly = resample.mean()
subset = yearly.reset_index()[['dt', 'AverageTemperature']]
subset.rename(columns={"dt": "ds", "AverageTemperature": "y"}, inplace=True)
subset.head()

pmodel = Prophet()
pmodel.fit(subset)

future = pmodel.make_future_dataframe(periods=20, freq='12M')
forecast = pmodel.predict(future)
forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head()

pmodel.plot(forecast)

print(forecast[forecast.ds == '2030-01-31'].iloc[0]['yhat'])

"""# Nouvelle section"""